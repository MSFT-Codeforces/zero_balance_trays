## Problem: The Clockmaker’s Balance Ledger

In the city of Gearford, an old clockmaker keeps a ledger of “energy tiles” used to calibrate a giant tower clock.

He owns a multiset of tiles containing:

- exactly `a` tiles of value **1**
- exactly `b` tiles of value **2**

For a calibration attempt, **every tile must be placed into exactly one of two trays**:

- the **Sun tray** (counts as **positive**, like a `+` sign)
- the **Moon tray** (counts as **negative**, like a `-` sign)

After placing all tiles, the clockmaker computes the **net energy**:

\[
(\text{sum of Sun tray}) - (\text{sum of Moon tray})
\]

You are given `q` calibration requests. In the `i`-th request, an integer `k` is given:

> **Exactly `k` tiles must go into the Sun tray** (so the remaining `a+b-k` tiles go into the Moon tray).

For each request, determine whether the clockmaker can make the **net energy exactly `0`**.

- If possible, output two integers:
  - `x`: how many **value-1** tiles are placed into the Sun tray
  - `y`: how many **value-2** tiles are placed into the Sun tray
- Otherwise output `-1`.

It is guaranteed that for fixed `(a, b, k)`, **if a solution exists then `(x, y)` is unique**.

---

### Input Format
- The first line contains an integer `t` — the number of test cases.
- Each test case starts with three integers `a`, `b`, `q`.
- Then follow `q` integers `k` (possibly across multiple lines).

### Output Format
For each query, print:
- `-1` if it is impossible  
- otherwise print `x y`

---

### Constraints
- `1 ≤ t ≤ 2⋅10^4`
- `0 ≤ a, b ≤ 10^18`
- `1 ≤ q ≤ 2⋅10^5`
- Sum of `q` over all test cases ≤ `2⋅10^5`
- Each query `k` fits in signed 64-bit  
  (If `k` is outside `0..a+b`, it is impossible.)

---

## Sample Input
```
2
4 1 5
0 1 2 3 5
3 10 3
5 8 13
```

## Sample Output
```
-1
-1
3 0
1 1
-1
-1
-1
-1
```

### Sample Explanation (first test case)
`a=4` ones and `b=1` two.
- For `k=2`, placing `x=3` ones in Sun would already exceed the number of Sun tiles, so the only valid answer is the one derived by equations; it ends up being `x=3,y=0`, which works only when `k=2`.

---

# Editorial

Let:

- `x` = number of **1-tiles** in the Sun tray  
  then `a-x` ones are in Moon
- `y` = number of **2-tiles** in the Sun tray  
  then `b-y` twos are in Moon

## 1) Exactly `k` tiles in the Sun tray
\[
x + y = k
\]

## 2) Net energy must be zero

Contribution of value-1 tiles:

- Sun contributes `+1` each: `+x`
- Moon contributes `-1` each: `-(a-x)`

So total from ones:
\[
x - (a-x) = 2x - a
\]

Contribution of value-2 tiles:

- Sun contributes `+2` each: `+2y`
- Moon contributes `-2` each: `-2(b-y)`

So total from twos:
\[
2y - 2(b-y) = 4y - 2b
\]

Net energy = 0:
\[
(2x-a) + (4y-2b) = 0
\Rightarrow 2x + 4y = a + 2b
\Rightarrow x + 2y = \frac{a+2b}{2}
\]

Let:
\[
H = \frac{a+2b}{2}
\]

Since `2b` is always even, `H` is an integer **iff `a` is even**.  
So if `a` is odd, **no query can ever work**.

When `a` is even, note:
\[
H = \frac{a}{2} + b
\]

## 3) Solve the system (unique candidate)

\[
\begin{cases}
x + y = k \\
x + 2y = H
\end{cases}
\]

Subtract the first from the second:
\[
y = H - k
\]
Then:
\[
x = k - y = k - (H-k) = 2k - H
\]

So for each query, the only possible candidate is:
- `y = H - k`
- `x = 2k - H`

It is feasible iff all bounds hold:

- `0 ≤ k ≤ a+b`
- `0 ≤ x ≤ a`
- `0 ≤ y ≤ b`

Each query is answered in **O(1)**.

---

# Reference Implementation (Python 3)

```python
import sys

def solve() -> None:
    it = iter(sys.stdin.buffer.read().split())
    t = int(next(it))
    out = []

    for _ in range(t):
        a = int(next(it))
        b = int(next(it))
        q = int(next(it))

        total = a + b

        # If a is odd, (a + 2b)/2 is not integer -> impossible for all queries.
        if a & 1:
            for _ in range(q):
                next(it)  # consume k
                out.append("-1")
            continue

        # H = (a + 2b)/2 = a/2 + b
        H = (a // 2) + b

        for _ in range(q):
            k = int(next(it))

            if k < 0 or k > total:
                out.append("-1")
                continue

            y = H - k
            x = 2 * k - H

            if 0 <= x <= a and 0 <= y <= b:
                out.append(f"{x} {y}")
            else:
                out.append("-1")

    sys.stdout.write("\n".join(out))

if __name__ == "__main__":
    solve()
```

