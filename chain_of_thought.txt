**[section_01]**
**Chain Title** Building a precise mental model of the task without thinking about algorithms.
**[atomic_01_01]**
Each test case specifies a multiset of tiles with only two possible values: there are exactly $a$ tiles of value $1$ and exactly $b$ tiles of value $2$. Tiles of the same value are interchangeable, so the only meaningful choices are how many of each value go to each tray.
**[atomic_01_02]**
For every query, every tile must be placed into exactly one of two trays:
- the Sun tray (its tile values add to a positive sum),
- the Moon tray (its tile values add to a negative sum).

No tile can be discarded or duplicated.
**[atomic_01_03]**
A query provides an integer $k$ with the rule: exactly $k$ tiles must be placed into the Sun tray. Therefore, exactly $a+b-k$ tiles are forced into the Moon tray. If $k$ is not in the range $[0,a+b]$, the query is invalid under the rules.
**[atomic_01_04]**
After placing all tiles, the net energy is computed as:
$$(\text{sum of values in Sun})-(\text{sum of values in Moon}).$$
The query asks whether the net energy can be made exactly $0$ while still placing exactly $k$ tiles in Sun.
**[atomic_01_05]**
When a query is solvable, the output must be two integers $(x,y)$:
- $x$ is the count of value-$1$ tiles placed in Sun,
- $y$ is the count of value-$2$ tiles placed in Sun.

If it is not solvable, output $-1$. The two constraints (exactly $k$ in Sun and net energy $0$) form a linear system in $(x,y)$ with at most one solution when consistent, so the output is deterministic.

---

**[section_02]**
**Chain Title** Walking through the provided sample test cases from the problem statement.
**[atomic_02_01]**
**First sample (first example in the statement.)** Input:
$t=3$. Test case 1: $a=0$, $b=2$, $q=2$ with $k=1$ then $k=0$. Total value $S=a+2b=4$, so net energy $0$ requires Sun sum $=S/2=2$. For $k=1$: we need one tile in Sun with sum $2$; the only possibility is one tile of value $2$, so $x=0$, $y=1$ → output `0 1`. For $k=0$: zero tiles in Sun gives Sun sum $0 \neq 2$ → output `-1`. So the first two lines of output are `0 1` and `-1`.
**[atomic_02_02]**
**First sample, test case 2.** $a=3$, $b=1$, $q=3$ with $k=0$, $k=2$, $k=4$. Here $S=3+2=5$ is odd, so $S/2$ is not an integer and net energy $0$ is impossible for every $k$. All three queries must output `-1`. That matches the statement output: `-1`, `-1`, `-1`.
**[atomic_02_03]**
**First sample, test case 3.** $a=2$, $b=3$, $q=4$ with $k=1$, $k=2$, $k=3$, $k=4$. $S=2+6=8$, so Sun sum must be $4$. We need $x+y=k$ and $x+2y=4$. $k=1$: max Sun sum with one tile is $2<4$ → `-1`. $k=2$: $y=2$, $x=0$; check $0\le x\le 2$, $0\le y\le 3$ → output `0 2`. $k=3$: $y=1$, $x=2$ → output `2 1`. $k=4$: $y=0$, $x=4$ but $x\le a=2$ fails → `-1`. So the four outputs are `-1`, `0 2`, `2 1`, `-1`, matching the statement.
**[atomic_02_04]**
**Second sample (second example in the statement.)** Single test case: $a=4$, $b=1$, $q=6$, queries $k=3,1,3,2,0,4$. $S=4+2=6$, Sun sum must be $3$. $k=3$: $x+y=3$, $x+2y=3$ → $y=0$, $x=3$; $0\le x\le 4$, $0\le y\le 1$ → `3 0`. $k=1$: $x+y=1$, $x+2y=3$ → $y=2$ but $y\le b=1$ fails → `-1`. $k=3$ again → `3 0`. $k=2$: $x+y=2$, $x+2y=3$ → $y=1$, $x=1$ → `1 1`. $k=0$: Sun sum $0\neq 3$ → `-1`. $k=4$: $x+y=4$, $x+2y=3$ gives $y=-1$ → `-1`. So the six outputs are `3 0`, `-1`, `3 0`, `1 1`, `-1`, `-1`, matching the statement.
**[atomic_02_05]**
These walkthroughs confirm that the stated inputs produce the stated outputs and illustrate: (1) $a=0$ with only value-$2$ tiles, (2) odd total sum so no query can succeed, (3) feasible and infeasible $k$ in the same test case with bounds $0\le x\le a$, $0\le y\le b$, and (4) repeated $k$ and ordering of queries. This chain does not describe an algorithmic approach; it only verifies the samples. There is no asymptotic cost to discuss here.

---

**[section_03]**
**Chain Title** Exploring brute-force tray assignments.
**[atomic_03_01]**
The most direct attempt is to decide for each of the $a+b$ tiles whether it goes to Sun or Moon, then check whether (1) exactly $k$ tiles were placed into Sun and (2) net energy equals $0$. This mirrors the statement exactly and is straightforward for tiny inputs.
**[atomic_03_02]**
This explores all sign assignments, which is $2^{a+b}$ possibilities. Even if we restrict to assignments with exactly $k$ Sun tiles, there are still $\binom{a+b}{k}$ possibilities, which is enormous for moderately large $a+b$.
**[atomic_03_03]**
Time complexity is exponential: $O(2^{a+b})$ in the worst case. Space can be kept small, but time dominates completely. This approach fails immediately once $a+b$ grows beyond a few dozen.
**[atomic_03_04]**
Because $a$ and $b$ can be as large as $10^{18}$, any method that treats each tile as an individual decision is fundamentally incompatible with the input limits, forcing a shift to count-based reasoning.

---

**[section_04]**
**Chain Title** Exploring per-query enumeration of feasible $(x,y)$ counts.
**[atomic_04_01]**
Since there are only values $1$ and $2$, any placement is determined by counts:
- choose $x$ ones for Sun (so $a-x$ ones are in Moon),
- choose $y$ twos for Sun (so $b-y$ twos are in Moon).
The query restriction becomes $x+y=k$.
**[atomic_04_02]**
A natural per-query method is to enumerate all possible $x$ values that could satisfy $x+y=k$:
- $x$ must satisfy $0 \le x \le a$,
- $y=k-x$ must satisfy $0 \le y \le b$.
For each feasible $(x,y)$ candidate, we would compute the net energy and check if it is $0$.
**[atomic_04_03]**
The number of candidates to scan is the size of the integer interval:
$$x \in [\max(0,k-b),\min(a,k)].$$
In the worst case this range length is $\Theta(\min(a,k))$, which can be as large as $10^{18}$.
**[atomic_04_04]**
Time complexity becomes $O(\min(a,k))$ per query (or similarly $O(\min(b,k))$ if scanning $y$). With up to $2\cdot 10^5$ queries, this is infeasible even when only one of $a$ or $b$ is large.
**[atomic_04_05]**
This is a clear improvement over exponential brute force, but it still relies on iterating over a potentially massive range of candidates. The next refinement must avoid linear scanning and instead narrow down to the right candidate more efficiently.

---

**[section_05]**
**Chain Title** Exploring binary search on a monotone function.
**[atomic_05_01]**
With $y=k-x$, the net energy becomes a function of a single variable $x$. For any fixed $(a,b,k)$, once $x$ is chosen, the pair $(x,y)$ is determined, so checking feasibility reduces to finding whether there exists an integer $x$ in the feasible range that yields net energy $0$.
**[atomic_05_02]**
When substituting $y=k-x$, the net energy expression becomes linear in $x$, meaning it changes in a single direction as $x$ increases (monotonic behavior). This is important because it lets us locate a zero (if it exists) without scanning every $x$.
**[atomic_05_03]**
Given monotonicity over the feasible interval
$$x \in [L,R]=[\max(0,k-b),\min(a,k)],$$
we can binary search for an $x$ where net energy is $0$. After binary search selects a candidate $x$, we compute $y=k-x$ and verify all constraints. This replaces $O(R-L+1)$ scanning with $O(\log(R-L+1))$ checks.
**[atomic_05_04]**
Complexity improves to:
- Time per query: $O(\log(\min(a,k)+1))$,
- Space: $O(1)$.
This is strictly better than the linear scan from the previous approach.
**[atomic_05_05]**
Despite being fast enough, binary search is still more complicated than necessary: the function is not just monotone, it is exactly linear, and the problem guarantees uniqueness when a solution exists. That suggests there should be a direct algebraic way to compute $(x,y)$ without any searching, motivating a final refinement to $O(1)$ per query.

---

**[section_06]**
**Chain Title** Deriving a closed-form solution from the linear system.
**[atomic_06_01]**
Let $x$ be the number of value-$1$ tiles in Sun and $y$ be the number of value-$2$ tiles in Sun. The query restriction “exactly $k$ tiles in Sun” becomes:
$$x+y=k.$$
**[atomic_06_02]**
Net energy equals:
$$(\text{Sun sum})-(\text{Moon sum}).$$
Ones contribute $x-(a-x)=2x-a$ and twos contribute $2y-2(b-y)=4y-2b$, so net energy $0$ implies:
$$(2x-a)+(4y-2b)=0.$$
**[atomic_06_03]**
Rearrange:
$$2x+4y=a+2b,$$
divide by $2$:
$$x+2y=\frac{a+2b}{2}.$$
Let:
$$H=\frac{a+2b}{2}.$$
A necessary condition is that $H$ is an integer, which happens exactly when $a$ is even.
**[atomic_06_04]**
If $a$ is odd, then $H$ is not an integer, so no solution can exist for any query in that test case. Every query output is $-1$, and we only need to consume the input values of $k$.
**[atomic_06_05]**
Assume $a$ is even. Then:
$$H=\frac{a}{2}+b.$$
Solve the system:
$$\begin{cases}
x+y=k \\
x+2y=H
\end{cases}$$
Subtract the first equation from the second:
$$y=H-k,$$
and then:
$$x=k-y=2k-H.$$
This produces exactly one candidate pair $(x,y)$ for each query.
**[atomic_06_06]**
The candidate is feasible if and only if all bounds are satisfied:
- $0 \le k \le a+b$,
- $0 \le x \le a$,
- $0 \le y \le b$.
If any bound fails, the unique candidate is invalid, so the answer must be $-1$.
**[atomic_06_07]**
Per-query time is $O(1)$: a few integer operations and comparisons. Space remains $O(1)$ besides storing output. This strictly improves upon the $O(\log n)$ binary search approach.
**[atomic_06_08]**
This constant-time approach also aligns with the uniqueness guarantee: since there is at most one solution, it is sufficient to compute the only possible candidate and validate it, rather than search among many possibilities.

---

**[section_07]**
**Chain Title** Translating the constant-time math into an input/output plan and validating with focused checks.
**[atomic_07_01]**
Because total queries across all test cases can be $2\cdot 10^5$, input reading should avoid per-integer overhead where possible, and output should be buffered. The critical requirement is to process each query with a constant amount of work.
**[atomic_07_02]**
A robust per-test-case sequence is:
1) read $a,b,q$ and compute $\text{total}=a+b$,  
2) if $a$ is odd: read and ignore $q$ values of $k$, output $-1$ for each,  
3) else compute $H=\frac{a}{2}+b$ once, and for each query compute $(x,y)$ as $(2k-H,\ H-k)$ and validate bounds.
**[atomic_07_03]**
Validation must include all three categories of failure:
- invalid $k$ outside $[0,a+b]$,
- $x$ outside $[0,a]$,
- $y$ outside $[0,b]$.
Even if $k$ is valid, computed $x$ or $y$ can be negative or exceed available counts, which must return $-1$.
**[atomic_07_04]**
A compact representation of the constant-time decision is:
```python
y = h - k
x = 2 * k - h
ok = (0 <= k <= a + b and 0 <= x <= a and 0 <= y <= b)
```
This highlights that there is no loop over candidates and no search.
**[atomic_07_05]**
Targeted correctness checks (as test ideas) include:
- $a$ odd: confirm all outputs are $-1$.
- $k=0$ and $k=a+b$: verify bounds behave correctly at extremes.
- $a=0$ or $b=0$: confirm the computed solution respects the forced $x=0$ or $y=0$ constraint when feasible.
- large values near $10^{18}$: confirm the logic depends only on integer arithmetic and comparisons.
**[atomic_07_06]**
Final complexity summary:
- Approach progression: $O(2^{a+b}) \to O(\min(a,k)) \to O(\log(\min(a,k)+1)) \to O(1)$ per query.
- Final complexity: $O(q)$ time per test case and $O(1)$ auxiliary space, which matches the constraints because it scales with the number of queries rather than the magnitude of $a$ and $b$.